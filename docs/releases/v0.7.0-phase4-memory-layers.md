# v0.7.0 — Phase 4: Five-Layer Memory System

> **Type:** Minor (additive — ไม่ break API เดิม, `oracle_learn`/`oracle_search` ยังทำงานเหมือนเดิม)  
> **Scope:** User Model + Procedural Memory + Semantic Enhancement + Episodic Memory + Learning Loop  
> **Risk:** Medium — เพิ่ม schema columns, MCP tools ใหม่, prompt builder changes  
> **Est. Effort:** ~2 สัปดาห์  
> **Prerequisites:** v0.6.0 (Phase 1 — Adaptive Hybrid Search + Smart Chunking) ✅ deployed  
> **Pillar:** Pillar 1 — Deep Memory System ★ CORE DIFFERENTIATOR (จาก BEYOND_OPENCLAW.md)

---

## Background

### ทำไมต้องทำ Phase นี้

ปัจจุบัน Oracle V2 เก็บ knowledge เป็น flat document types: `principle | pattern | learning | retro`  
ทุกอย่างถูกปฏิบัติเท่าเทียมกัน — ไม่แยกว่าข้อมูลไหนเป็น "ความชอบของ user", "วิธีทำงาน", "เรื่องที่เกิดขึ้น" หรือ "ข้อเท็จจริง"

**ปัญหาที่เกิด:**
1. Agent ถาม Oracle → ได้ข้อมูลทุกประเภทปน → ต้องเดาเองว่าข้อมูลไหนเกี่ยวกับอะไร
2. ไม่มี User Model → AI ไม่รู้ว่า user ชอบอะไร, เชี่ยวชาญเรื่องอะไร
3. ไม่มี Procedural Memory → AI ไม่จำ "วิธีที่เคยทำสำเร็จ" → ทำซ้ำทุกครั้ง
4. ไม่มี temporal decay → ข้อมูลเก่า 6 เดือนกับข้อมูลเมื่อวาน มีน้ำหนักเท่ากัน
5. Prompt Builder ลองดึง `type: 'preference'` แต่ type นี้ไม่มีอยู่ → ได้ผลลัพธ์เป็นศูนย์เสมอ

### สิ่งที่จะเปลี่ยน

JellyCore จะมี memory 5 ชั้น ตาม cognitive memory model:

```
┌─────────────────────────────────────────────────────────┐
│ Layer 5: Working Memory (ระยะสั้น ~session)             │
│ → อยู่ใน container process อยู่แล้ว ← ไม่ต้องเปลี่ยน   │
├─────────────────────────────────────────────────────────┤
│ Layer 4: Episodic Memory (เหตุการณ์ ~สัปดาห์/เดือน)     │
│ → conversation summaries + interaction patterns         │
│ → เพิ่ม: temporal decay, access-based promotion         │
├─────────────────────────────────────────────────────────┤
│ Layer 3: Semantic Memory (ความรู้ ~ถาวร) ← มีแล้ว       │
│ → Oracle knowledge base (5,500+ docs)                   │
│ → เพิ่ม: access frequency boost, confidence score       │
├─────────────────────────────────────────────────────────┤
│ Layer 2: Procedural Memory (วิธีทำ ~ถาวร) ★ NEW        │
│ → "เวลา debug → ดู log ก่อน → ตรวจ config → test"     │
│ → เรียนรู้จาก corrections + repeated patterns           │
├─────────────────────────────────────────────────────────┤
│ Layer 1: User Model (โมเดลผู้ใช้ ~ถาวร) ★ NEW         │
│ → expertise, preferences, communication style           │
│ → ใช้ทุก request เพื่อ personalize response             │
└─────────────────────────────────────────────────────────┘
```

**Layer 5 (Working Memory)** ไม่ต้องทำอะไร — อยู่ใน container context ตามธรรมชาติแล้ว  
**Focus ของ Phase นี้:** Layer 1-4 + Learning Loop Enhancement

---

## Changes

### Part A — Schema & Type Extensions (Foundation)

เพิ่ม `memory_layer` column ใน oracle_documents เพื่อแยกชั้น  
**ไม่เปลี่ยน** `type` column เดิม (principle/pattern/learning/retro ยังใช้ได้)

#### A.1 — Schema Migration

**File:** `oracle-v2/src/db/schema.ts`

```typescript
// เพิ่ม column ใน oracleDocuments
memoryLayer: text('memory_layer'),  // 'user_model' | 'procedural' | 'semantic' | 'episodic' | null (legacy)
confidence: real('confidence'),     // 0.0-1.0 ความมั่นใจในข้อมูล
accessCount: integer('access_count').default(0),
lastAccessedAt: integer('last_accessed_at'),
decayScore: real('decay_score').default(1.0),  // 1.0 = fresh, 0.0 = stale
expiresAt: integer('expires_at'),  // TTL (null = never)
```

**File:** `oracle-v2/src/db/index.ts`

```sql
-- Migration (additive — ไม่ break existing data)
ALTER TABLE oracle_documents ADD COLUMN memory_layer TEXT;
ALTER TABLE oracle_documents ADD COLUMN confidence REAL;
ALTER TABLE oracle_documents ADD COLUMN access_count INTEGER DEFAULT 0;
ALTER TABLE oracle_documents ADD COLUMN last_accessed_at INTEGER;
ALTER TABLE oracle_documents ADD COLUMN decay_score REAL DEFAULT 1.0;
ALTER TABLE oracle_documents ADD COLUMN expires_at INTEGER;

CREATE INDEX IF NOT EXISTS idx_memory_layer ON oracle_documents(memory_layer);
CREATE INDEX IF NOT EXISTS idx_decay_score ON oracle_documents(decay_score);
```

**Backward compatibility:** `memory_layer = null` สำหรับ documents เดิม → ถือเป็น `semantic` layer โดย default  
ไม่ต้อง migrate data เดิม — null = semantic โดย implicit

**LOC est.:** ~25

#### A.2 — Type Extensions

**File:** `oracle-v2/src/types.ts`

```typescript
// เพิ่ม type ใหม่
export type MemoryLayer = 'user_model' | 'procedural' | 'semantic' | 'episodic';

export interface OracleDocument {
  // ... existing fields ...
  memory_layer?: MemoryLayer;
  confidence?: number;
  access_count?: number;
  last_accessed_at?: number;
  decay_score?: number;
  expires_at?: number;
}

// User Model structure (Layer 1)
export interface UserModel {
  userId: string;
  expertise: Record<string, 'novice' | 'intermediate' | 'advanced' | 'expert'>;
  preferences: {
    language: 'th' | 'en' | 'mixed';
    responseLength: 'concise' | 'detailed' | 'auto';
    responseStyle: 'formal' | 'casual' | 'auto';
    codeStyle?: string;  // e.g., 'functional', 'oop'
  };
  commonTopics: string[];
  timezone: string;
  activeHours?: { start: number; end: number };
  notes: string[];  // free-form personality/compatibility notes
  updatedAt: number;
}

// Procedural Memory structure (Layer 2)
export interface ProceduralMemory {
  trigger: string;      // "เมื่อ user ถาม deploy"
  procedure: string[];  // ["แสดง checklist ก่อน", "ถามเรื่อง environment"]
  source: 'correction' | 'repeated_pattern' | 'explicit';
  successCount: number;
  lastUsed: number;
}
```

**LOC est.:** ~50

**Part A Subtotal:** ~75 LOC

---

### Part B — User Model Layer (Layer 1) ★

User Model เก็บข้อมูลเกี่ยวกับ user: ความชอบ, expertise level, communication style  
ถูกดึงมาใส่ system prompt **ทุก request** เพื่อ personalize response

#### B.1 — User Model Storage

**ไฟล์ใหม่:** `oracle-v2/src/memory/user-model.ts`

```typescript
/**
 * User Model Layer (Layer 1)
 * 
 * เก็บข้อมูลเกี่ยวกับ user ใน oracle_documents
 * - memory_layer = 'user_model'
 * - type = 'learning' (ใช้ type เดิม)
 * - concepts = ['memory:user_model', userId]
 * 
 * ข้อมูลใน content เป็น JSON ของ UserModel interface
 */

export class UserModelStore {
  /**
   * ดึง User Model สำหรับ userId
   * ถ้ายังไม่มี → สร้าง default model
   */
  async get(userId: string): Promise<UserModel>;

  /**
   * อัปเดต User Model (merge กับ existing)
   * ใช้ deep merge — ไม่ overwrite ทั้ง object
   * เช่น update({ expertise: { docker: 'expert' } })
   * → merge กับ expertise เดิม ไม่ลบ key อื่น
   */
  async update(userId: string, partial: Partial<UserModel>): Promise<UserModel>;

  /**
   * ลบ User Model (reset)
   */
  async reset(userId: string): Promise<void>;
}
```

**Storage strategy:**
- 1 document per user: `id = 'user_model_{userId}'`
- `memory_layer = 'user_model'`
- `type = 'learning'` (reuse existing type)
- `concepts = ['memory:user_model', 'user:{userId}']`
- `content = JSON.stringify(userModel)`
- **ไม่สร้างไฟล์ Markdown** — เก็บใน SQLite + ChromaDB อย่างเดียว (ข้อมูลส่วนตัว)
- `is_private = 1` (ไม่ให้ agent อื่นเห็น)

**Default User Model (สร้างอัตโนมัติเมื่อไม่มี):**
```typescript
const DEFAULT_USER_MODEL: UserModel = {
  userId: '',
  expertise: {},
  preferences: {
    language: 'th',
    responseLength: 'auto',
    responseStyle: 'casual',
  },
  commonTopics: [],
  timezone: 'Asia/Bangkok',
  notes: [],
  updatedAt: Date.now(),
};
```

**LOC est.:** ~120

#### B.2 — MCP Tool: `oracle_user_model`

**File:** `oracle-v2/src/server.ts` + `oracle-v2/src/server/handlers.ts`

เพิ่ม 2 endpoints:

```typescript
// GET /api/user-model?userId=xxx
// → ดึง User Model
app.get('/api/user-model', async (c) => {
  const userId = c.req.query('userId') || 'default';
  return c.json(await handleGetUserModel(userId));
});

// POST /api/user-model
// body: { userId, updates: Partial<UserModel> }
// → อัปเดต User Model (deep merge)
app.post('/api/user-model', async (c) => {
  const { userId, updates } = await c.req.json();
  return c.json(await handleUpdateUserModel(userId || 'default', updates));
});
```

**Handler implementation:**

```typescript
export async function handleGetUserModel(userId: string): Promise<UserModel> {
  const store = getUserModelStore();
  return store.get(userId);
}

export async function handleUpdateUserModel(
  userId: string,
  updates: Partial<UserModel>
): Promise<{ success: boolean; model: UserModel }> {
  const store = getUserModelStore();
  const model = await store.update(userId, updates);
  // Invalidate search cache — context changed
  searchCache.reset();
  return { success: true, model };
}
```

**Agent เรียกใช้ (ผ่าน MCP tool ของ NanoClaw):**
```
oracle_user_model_get: ดึงข้อมูล user → ใส่ใน system prompt
oracle_user_model_update: อัปเดตเมื่อ user บอก preference ใหม่
```

**ตัวอย่างการใช้งาน:**
- User: "ฉันชอบให้ตอบสั้นๆ"
  → Agent เรียก `oracle_user_model_update({ preferences: { responseLength: 'concise' } })`
- User: "ฉันรู้เรื่อง Docker ดีแล้ว ไม่ต้องอธิบายพื้นฐาน"
  → Agent เรียก `oracle_user_model_update({ expertise: { docker: 'expert' } })`

**LOC est.:** ~60

#### B.3 — Prompt Builder Integration

**File:** `nanoclaw/src/prompt-builder.ts`

เปลี่ยน query ที่ 2 (ปัจจุบันดึง `type: 'preference'` ที่ไม่มีอยู่จริง)  
→ ดึง User Model จาก endpoint ใหม่แทน:

```typescript
// Before (broken — type 'preference' doesn't exist):
const prefsQuery = `${oracleUrl}/api/search?q=user+preferences+${userId}&type=preference&limit=3&mode=vector`;

// After (ดึง User Model ตรงๆ):
const userModelQuery = `${oracleUrl}/api/user-model?userId=${userId}`;
```

**XML output format ใน system prompt:**
```xml
<user_model confidence="0.85">
  <expertise>
    <topic name="docker" level="expert"/>
    <topic name="typescript" level="advanced"/>
    <topic name="kubernetes" level="novice"/>
  </expertise>
  <preferences>
    <language>th</language>
    <response_length>concise</response_length>
    <response_style>casual</response_style>
  </preferences>
  <common_topics>docker, oracle-v2, nanoclaw, jellycore</common_topics>
  <notes>
    - ชอบให้อธิบายเป็น bullet points
    - ใช้งานทั้งไทยและอังกฤษ แต่ไทยเป็นหลัก
  </notes>
</user_model>
```

**ผลลัพธ์:** Agent เห็น user model ทุก request → ปรับ response ตาม preference + expertise

**LOC est.:** ~40

**Part B Subtotal:** ~220 LOC

---

### Part C — Procedural Memory (Layer 2) ★

"ถ้า user ถามเรื่อง X → ควรทำ Y ก่อน"  
เรียนรู้จาก corrections, repeated success patterns, explicit teaching

#### C.1 — Procedural Memory Storage

**ไฟล์ใหม่:** `oracle-v2/src/memory/procedural.ts`

```typescript
/**
 * Procedural Memory Layer (Layer 2)
 * 
 * เก็บ "วิธีทำงาน" ที่ AI เรียนรู้ ใน oracle_documents
 * - memory_layer = 'procedural'
 * - type = 'pattern' (reuse existing type)
 * - concepts = ['memory:procedural', ...topic concepts]
 * 
 * content เป็น JSON ของ ProceduralMemory interface
 */

export class ProceduralStore {
  /**
   * ค้นหา procedural memories ที่ match กับ task context
   * ใช้ semantic search → หา trigger ที่คล้ายกับ current task
   */
  async find(taskContext: string, limit?: number): Promise<ProceduralMemory[]>;

  /**
   * บันทึก procedural pattern ใหม่
   * ถ้ามี trigger คล้ายกัน (similarity > 0.85) → merge แทน create
   */
  async learn(memory: Omit<ProceduralMemory, 'successCount' | 'lastUsed'>): Promise<string>;

  /**
   * บันทึกว่า procedure ถูกใช้แล้ว (เพิ่ม successCount)
   */
  async recordUsage(id: string): Promise<void>;
}
```

**Storage strategy:**
- `id = 'procedural_{hash(trigger)}'`
- `memory_layer = 'procedural'`
- `type = 'pattern'`
- `concepts = ['memory:procedural', ...extracted concepts from trigger]`
- `content = JSON.stringify(proceduralMemory)`
- ถูก index ใน FTS5 + ChromaDB → searchable ด้วย natural language
- Merge logic: ถ้า procedural ซ้ำ → merge procedure steps, increment successCount

**LOC est.:** ~130

#### C.2 — MCP Tool: `oracle_procedural`

**File:** `oracle-v2/src/server.ts` + `oracle-v2/src/server/handlers.ts`

```typescript
// GET /api/procedural?q=deploy+docker&limit=3
// → ค้นหา procedural memories ที่เกี่ยวข้อง
app.get('/api/procedural', async (c) => {
  const q = c.req.query('q') || '';
  const limit = parseInt(c.req.query('limit') || '3');
  return c.json(await handleGetProcedural(q, limit));
});

// POST /api/procedural
// body: { trigger, procedure[], source }
// → บันทึก procedural memory ใหม่
app.post('/api/procedural', async (c) => {
  const { trigger, procedure, source } = await c.req.json();
  return c.json(await handleLearnProcedural(trigger, procedure, source));
});
```

**ตัวอย่างการใช้งาน:**
- Agent ตอบ user สำเร็จ user ชม → Agent เรียก `oracle_procedural_learn`:
  ```json
  {
    "trigger": "user ถามเรื่อง deploy Docker",
    "procedure": [
      "ถาม environment ก่อน (dev/staging/prod)",
      "ตรวจ docker-compose.yml",
      "แสดง checklist ก่อน deploy",
      "รัน docker compose up -d --build"
    ],
    "source": "repeated_pattern"
  }
  ```
- ครั้งต่อไป user ถาม deploy → Agent ค้น procedural → เห็น checklist → ทำตามเลย

**LOC est.:** ~60

#### C.3 — Prompt Builder Integration

**File:** `nanoclaw/src/prompt-builder.ts`

เพิ่ม query ที่ 5 (parallel กับ 4 queries เดิม):

```typescript
// Query 5: Procedural memory for current task
const proceduralQuery = `${oracleUrl}/api/procedural?q=${encodeURIComponent(userMessage)}&limit=3`;
```

**XML output:**
```xml
<procedural_memory>
  <procedure trigger="deploy Docker" confidence="0.9" used="12 times">
    <step>1. ถาม environment (dev/staging/prod)</step>
    <step>2. ตรวจ docker-compose.yml</step>
    <step>3. แสดง checklist ก่อน deploy</step>
    <step>4. รัน docker compose up -d --build</step>
  </procedure>
</procedural_memory>
```

**LOC est.:** ~30

**Part C Subtotal:** ~220 LOC

---

### Part D — Semantic Memory Enhancement (Layer 3)

Semantic Memory คือ knowledge base ปัจจุบัน — เพิ่ม temporal awareness + access tracking

#### D.1 — Access Tracking & Decay

**File:** `oracle-v2/src/server/handlers.ts` → `handleSearch()`

ทุกครั้งที่ document ถูก return จาก search:

```typescript
// After search results are computed, before returning:
for (const result of results) {
  // Increment access count + update last_accessed_at
  db.update(oracleDocuments)
    .set({
      accessCount: sql`COALESCE(access_count, 0) + 1`,
      lastAccessedAt: Date.now(),
    })
    .where(eq(oracleDocuments.id, result.id))
    .run();
}
```

**ทำแบบ async ไม่ block response** — fire-and-forget update

**LOC est.:** ~20

#### D.2 — Decay Score Computation

**ไฟล์ใหม่:** `oracle-v2/src/memory/decay.ts`

```typescript
/**
 * Temporal Decay + Access Boost
 * 
 * ค่า decay_score ใช้ปรับ search ranking:
 * - ข้อมูลใหม่ + เข้าถึงบ่อย → score สูง
 * - ข้อมูลเก่า + ไม่เคยเข้าถึง → score ต่ำ
 * 
 * สูตร: decay_score = recencyFactor × accessFactor
 * 
 * recencyFactor = e^(-λ × daysSinceUpdate)
 *   λ = 0.01 → half-life ~69 วัน (ข้อมูลอายุ 69 วัน = 0.5)
 * 
 * accessFactor = min(1.0, 0.5 + (accessCount × 0.05))
 *   → เข้าถึง 10 ครั้ง = factor 1.0
 *   → ไม่เคยเข้าถึง = factor 0.5
 * 
 * ข้อยกเว้น:
 * - memory_layer = 'user_model' → decay_score = 1.0 เสมอ (ไม่ decay)
 * - memory_layer = 'procedural' → λ = 0.005 (ช้ากว่า, half-life ~139 วัน)
 */

export function computeDecayScore(doc: {
  updatedAt: number;
  accessCount: number;
  memoryLayer?: string;
}): number;

/**
 * Background job: อัปเดต decay_score ทุก document
 * เรียกทุก 6 ชั่วโมง (หรือเมื่อ /api/index เสร็จ)
 */
export async function refreshAllDecayScores(): Promise<{ updated: number }>;
```

**LOC est.:** ~60

#### D.3 — Search Ranking Integration

**File:** `oracle-v2/src/server/handlers.ts` → `combineSearchResults()`

เพิ่ม decay_score เข้า RRF merge:

```typescript
// Before:
// rrfScore += profile.ftsBoost * (1 / (K + rank));

// After:
// rrfScore += profile.ftsBoost * (1 / (K + rank)) * (doc.decayScore || 1.0);
```

**ผลกระทบ:**
- ข้อมูลที่ถูกเข้าถึงบ่อยและล่าสุด → rank สูงขึ้น
- ข้อมูลเก่าที่ไม่เคยเข้าถึง → ค่อยๆ จมลง (ไม่ถูกลบ — แค่ rank ต่ำลง)
- User Model + Procedural Memory ไม่ decay → เสถียรเสมอ

**LOC est.:** ~15

#### D.4 — Confidence Score for Learnings

**File:** `oracle-v2/src/server/handlers.ts` → `handleLearn()`

เพิ่ม confidence score เมื่อ learn:

```typescript
// Confidence rules:
// - origin = 'human' (user บอกเอง)      → confidence = 0.95
// - origin = 'mother' (จาก admin/owner)  → confidence = 0.90
// - source มี URL/reference              → confidence = 0.80
// - auto-extracted (ไม่มี source)         → confidence = 0.60
// - from correction (user แก้ AI)        → confidence = 0.85
```

**LOC est.:** ~20

**Part D Subtotal:** ~115 LOC

---

### Part E — Episodic Memory with Decay (Layer 4)

Episodic Memory = "เรื่องที่เกิดขึ้น" — conversation summaries, interaction records

#### E.1 — Episodic Summary on Session End

**ไฟล์ใหม่:** `oracle-v2/src/memory/episodic.ts`

```typescript
/**
 * Episodic Memory Layer (Layer 4)
 * 
 * เก็บ summarized conversation episodes
 * - memory_layer = 'episodic'
 * - type = 'retro' (reuse existing type)
 * - concepts = ['memory:episodic', 'session:{date}', ...topic concepts]
 * - expires_at = created_at + 90 days (TTL)
 * 
 * สร้างจาก:
 * 1. Container output summary (post-task extractiion)
 * 2. oracle_episodic_summarize MCP tool (explicit)
 */

export class EpisodicStore {
  /**
   * บันทึก episode สรุปจากงาน
   * Auto-extracts: topics discussed, decisions made, user satisfaction
   */
  async record(episode: {
    userId: string;
    groupId: string;
    summary: string;
    topics: string[];
    outcome: 'success' | 'partial' | 'failed' | 'unknown';
    durationMs: number;
  }): Promise<string>;

  /**
   * ค้นหา episodes ที่เกี่ยวข้องกับ topic
   */
  async findRelated(topic: string, limit?: number): Promise<EpisodicMemory[]>;

  /**
   * ลบ episodes ที่หมดอายุ (TTL expired)
   * เรียกจาก background job
   */
  async purgeExpired(): Promise<{ removed: number; archived: number }>;
}
```

**TTL strategy:**
- Default TTL: 90 วัน
- Access ต่ออายุ: ถ้าถูก search hit → reset TTL อีก 30 วัน
- ก่อนลบ: archive เป็น compact summary (1 บรรทัด) เก็บถาวรใน `type: 'retro'`

**LOC est.:** ~120

#### E.2 — MCP Tool: `oracle_episodic`

**File:** `oracle-v2/src/server.ts`

```typescript
// POST /api/episodic
// body: { userId, groupId, summary, topics[], outcome, durationMs }
// → บันทึก episode
app.post('/api/episodic', async (c) => {
  const body = await c.req.json();
  return c.json(await handleRecordEpisode(body));
});

// GET /api/episodic?q=topic&userId=xxx&limit=5
// → ค้นหา recent episodes
app.get('/api/episodic', async (c) => {
  const q = c.req.query('q') || '';
  const userId = c.req.query('userId');
  const limit = parseInt(c.req.query('limit') || '5');
  return c.json(await handleSearchEpisodes(q, userId, limit));
});
```

**ใช้โดย NanoClaw:**
- หลัง container จบ task → NanoClaw สรุปแล้วเรียก `POST /api/episodic`
- ก่อนสร้าง container → ดึง recent episodes เข้า context

**LOC est.:** ~50

#### E.3 — Prompt Builder: Recent Episodes

**File:** `nanoclaw/src/prompt-builder.ts`

เพิ่ม query ที่ 6:

```typescript
// Query 6: Recent episodes for context continuity
const episodicQuery = `${oracleUrl}/api/episodic?userId=${userId}&limit=3`;
```

**XML output:**
```xml
<recent_episodes>
  <episode date="2026-02-15" outcome="success">
    เรื่อง: implement Smart Chunker สำหรับ bilingual text
    หัวข้อ: chunker, thai-nlp, indexer
    ผลลัพธ์: ทำสำเร็จ deploy แล้ว
  </episode>
  <episode date="2026-02-14" outcome="success">
    เรื่อง: implement Adaptive Hybrid Search
    หัวข้อ: query-classifier, search, rrf
    ผลลัพธ์: 24 tests pass, deployed
  </episode>
</recent_episodes>
```

**ผลลัพธ์:** Agent เห็น "เมื่อวานเราทำอะไร" → ตอบต่อเนื่องได้ ไม่ต้องถามใหม่ทุกครั้ง

**LOC est.:** ~35

**Part E Subtotal:** ~205 LOC

---

### Part F — Enhanced Learning Loop

ปรับ `handleLearn()` เดิมให้ route ข้อมูลไปยัง memory layer ที่ถูกต้อง

#### F.1 — Learning Router

**File:** `oracle-v2/src/server/handlers.ts` → `handleLearn()`

เพิ่ม `layer` parameter (optional, backward compatible):

```typescript
async handleLearn(
  pattern: string,
  source?: string,
  concepts?: string[],
  origin?: string,
  project?: string,
  cwd?: string,
  layer?: MemoryLayer,  // NEW: ระบุ layer ปลายทาง
): Promise<LearnResponse>
```

**Auto-detection ถ้าไม่ระบุ layer:**

```typescript
function detectMemoryLayer(pattern: string, concepts?: string[]): MemoryLayer {
  // Check concepts first
  if (concepts?.some(c => c.startsWith('memory:user_model'))) return 'user_model';
  if (concepts?.some(c => c.startsWith('memory:procedural'))) return 'procedural';
  if (concepts?.some(c => c.startsWith('memory:episodic'))) return 'episodic';

  // Heuristic detection
  const lower = pattern.toLowerCase();

  // User Model signals
  if (/(?:user|ผู้ใช้)\s*(?:ชอบ|ไม่ชอบ|prefer|ต้องการ|expertise)/i.test(lower)) {
    return 'user_model';
  }

  // Procedural signals
  if (/(?:เมื่อ|when|ถ้า|if).*(?:→|ให้|then|ทำ|should)/i.test(lower)) {
    return 'procedural';
  }

  // Default
  return 'semantic';
}
```

**Routing logic:**
```
handleLearn(pattern, ..., layer?)
    │
    ├── layer = 'user_model'
    │   → UserModelStore.update() (merge into user model)
    │   → ไม่สร้าง Markdown file (private)
    │
    ├── layer = 'procedural'
    │   → ProceduralStore.learn() (create/merge procedural)
    │   → ไม่สร้าง Markdown file
    │
    ├── layer = 'episodic'
    │   → EpisodicStore.record()
    │   → ไม่สร้าง Markdown file
    │
    └── layer = 'semantic' (default, backward compatible)
        → existing flow unchanged
        → สร้าง Markdown file + SQLite + FTS5 + ChromaDB
```

**Backward compatibility:** 
- ไม่ส่ง `layer` = ทำงานเหมือนเดิมทุกประการ (semantic layer)
- API endpoint ไม่เปลี่ยน: `POST /api/learn`
- Request body เพิ่ม optional field `layer`

**LOC est.:** ~60

#### F.2 — Contradiction Detection (Basic)

**File:** `oracle-v2/src/server/handlers.ts` → `handleLearn()` (within semantic path)

เมื่อ learn ข้อมูล semantic ใหม่ → ตรวจว่ามีข้อมูลเดิมที่ขัดแย้งไหม:

```typescript
// After deciding to store as semantic:
const existing = await searchForContradictions(pattern);

if (existing) {
  // Return warning — ไม่ block การ store (ยังเก็บข้อมูลใหม่)
  return {
    success: true,
    documentId,
    warning: {
      type: 'potential_contradiction',
      existingId: existing.id,
      existingContent: existing.content.substring(0, 200),
      similarity: existing.score,
      message: `พบข้อมูลที่อาจขัดแย้ง (similarity=${existing.score.toFixed(2)})`
    }
  };
}
```

**searchForContradictions():**
```typescript
async function searchForContradictions(newContent: string): Promise<SearchResult | null> {
  // Search ChromaDB for highly similar existing docs
  const results = await chromaClient.query(newContent, 3);
  
  for (const result of results) {
    // High similarity (>0.85) but different content → potential contradiction
    if (result.score > 0.85) {
      const contentSimilarity = computeTextSimilarity(newContent, result.content);
      if (contentSimilarity < 0.7) {
        // Similar topic but different content → flag
        return result;
      }
    }
  }
  return null;
}
```

**หมายเหตุ:** Phase นี้ทำ detection อย่างเดียว (return warning)  
Phase 6 จะทำ resolution (ถาม user / auto-supersede)

**LOC est.:** ~50

#### F.3 — Background Decay Job

**File:** `oracle-v2/src/server.ts` (startup)

เรียก decay refresh ทุก 6 ชั่วโมง + เมื่อ index เสร็จ + เมื่อ server start:

```typescript
// On server startup:
await refreshAllDecayScores();

// Every 6 hours:
setInterval(async () => {
  const result = await refreshAllDecayScores();
  console.log(`[Decay] Updated ${result.updated} documents`);
  
  // Purge expired episodic memories
  const episodic = getEpisodicStore();
  const purged = await episodic.purgeExpired();
  if (purged.removed > 0) {
    console.log(`[Episodic] Purged ${purged.removed} expired, archived ${purged.archived}`);
  }
}, 6 * 60 * 60 * 1000);
```

**LOC est.:** ~20

**Part F Subtotal:** ~130 LOC

---

### Part G — Layer-Aware Search

ปรับ `handleSearch()` ให้ filter/boost ตาม memory layer

#### G.1 — Layer Filter Parameter

**File:** `oracle-v2/src/server/handlers.ts` → `handleSearch()`

```typescript
// เพิ่ม query parameter:
// GET /api/search?q=...&layer=user_model (filter เฉพาะ layer)
// GET /api/search?q=...&layer=semantic,episodic (multiple layers)
// GET /api/search?q=... (ไม่ส่ง = ทุก layer, เหมือนเดิม)

const layer = c.req.query('layer');
const layerFilter = layer ? layer.split(',') : null;

// In SQL query:
if (layerFilter) {
  // WHERE memory_layer IN (...)
  // null treated as 'semantic' for legacy docs
}
```

**LOC est.:** ~25

#### G.2 — Layer-based Score Boosting

**File:** `oracle-v2/src/server/handlers.ts` → `combineSearchResults()`

เพิ่ม boost สำหรับ layer ที่สอดคล้องกับ query type:

```typescript
// Query type → preferred layers:
// exact query → boost: semantic (facts)
// semantic query (how-to) → boost: procedural > semantic
// semantic query (recall) → boost: episodic > semantic
// all queries → always include: user_model (but don't boost ranking)

function getLayerBoost(layer: MemoryLayer | null, queryType: QueryType): number {
  if (!layer || layer === 'semantic') return 1.0;
  if (layer === 'procedural' && queryType === 'semantic') return 1.2;
  if (layer === 'episodic' && queryType === 'semantic') return 1.1;
  if (layer === 'user_model') return 0.5;  // User model ดึงจาก prompt builder, ไม่ต้อง rank สูงใน search
  return 1.0;
}
```

**LOC est.:** ~20

**Part G Subtotal:** ~45 LOC

---

## Summary

### File Changes

| File | Type | Part | LOC |
|------|------|------|-----|
| `oracle-v2/src/db/schema.ts` | Modified | A | ~15 |
| `oracle-v2/src/db/index.ts` | Modified | A | ~10 |
| `oracle-v2/src/types.ts` | Modified | A | ~50 |
| `oracle-v2/src/memory/user-model.ts` | **New** | B | ~120 |
| `oracle-v2/src/memory/procedural.ts` | **New** | C | ~130 |
| `oracle-v2/src/memory/decay.ts` | **New** | D | ~60 |
| `oracle-v2/src/memory/episodic.ts` | **New** | E | ~120 |
| `oracle-v2/src/server.ts` | Modified | B,C,E,F | ~40 |
| `oracle-v2/src/server/handlers.ts` | Modified | B,C,D,E,F,G | ~180 |
| `nanoclaw/src/prompt-builder.ts` | Modified | B,C,E | ~105 |
| **Total** | | | **~830 LOC** |

### New MCP Tools / API Endpoints

| Endpoint | Method | Purpose | Layer |
|----------|--------|---------|-------|
| `/api/user-model` | GET | ดึง User Model | Layer 1 |
| `/api/user-model` | POST | อัปเดต User Model | Layer 1 |
| `/api/procedural` | GET | ค้น procedural memories | Layer 2 |
| `/api/procedural` | POST | บันทึก procedure | Layer 2 |
| `/api/episodic` | GET | ค้น recent episodes | Layer 4 |
| `/api/episodic` | POST | บันทึก episode | Layer 4 |

Existing endpoints ที่เปลี่ยน:
| Endpoint | Change |
|----------|--------|
| `POST /api/learn` | เพิ่ม `layer` parameter (optional) + contradiction detection |
| `GET /api/search` | เพิ่ม `layer` filter + decay score in ranking |

### Implementation Order (แนะนำ)

```
Part A (Foundation)     → schema + types
          ↓
Part B (User Model)     → storage + MCP + prompt builder
Part C (Procedural)     → storage + MCP + prompt builder
          ↓ (independent, ทำคู่กันได้)
Part D (Decay System)   → computation + search integration
Part E (Episodic)       → storage + MCP + prompt builder
          ↓
Part F (Learning Loop)  → router + contradiction + background job
Part G (Layer Search)   → filter + boost
```

**ทำ Part A → B → C ก่อน** (core value สูงสุด)  
Part D-G เสริมแต่ไม่จำเป็นต้องทำพร้อมกัน

### Backward Compatibility Guarantee

| สิ่งที่ไม่เปลี่ยน | เหตุผล |
|------------------|--------|
| `POST /api/learn` (ไม่ส่ง `layer`) | ทำงานเหมือนเดิม 100% — default to semantic |
| `GET /api/search` (ไม่ส่ง `layer`) | ค้นทุก layer — ผลลัพธ์เหมือนเดิม + decay boost เล็กน้อย |
| `GET /api/consult` | ไม่เปลี่ยน — ค้น principle + pattern เหมือนเดิม |
| `oracle_documents.type` | ไม่เปลี่ยน — `memory_layer` เป็น column แยก |
| Existing documents | `memory_layer = null` → treated as semantic (implicit) |
| Markdown files ใน `ψ/memory/` | ยังถูกสร้างสำหรับ semantic layer เหมือนเดิม |

### Testing Strategy

| Test Group | ไฟล์ | ทดสอบอะไร |
|-----------|------|-----------|
| User Model | `user-model.test.ts` | CRUD, deep merge, default creation, private flag |
| Procedural | `procedural.test.ts` | CRUD, similarity merge, usage tracking |
| Decay | `decay.test.ts` | Score computation, half-life, access boost, layer exceptions |
| Episodic | `episodic.test.ts` | Record, search, TTL purge, archive |
| Learning Router | `learn-router.test.ts` | Auto-detection, explicit layer, backward compat |
| Contradiction | `contradiction.test.ts` | High similarity different content, same content no flag |
| Integration | `memory-integration.test.ts` | Search with layer filter, decay in ranking, prompt builder XML |

### Risk Assessment

| ความเสี่ยง | ระดับ | วิธีจัดการ |
|-----------|-------|-----------|
| Schema migration ทำ column เดิมหาย | ต่ำ | ใช้ `ALTER TABLE ADD COLUMN` — additive only |
| Decay score ทำให้ข้อมูลสำคัญจมหาย | ต่ำ | Half-life 69 วัน = ยาวพอ + access ต่ออายุ + user_model ไม่ decay |
| User Model ถูก overwrite ผิด | กลาง | Deep merge ไม่ overwrite ทั้ง object + log ทุก update |
| Contradiction detection false positive | กลาง | Threshold 0.85 similarity สูงมาก + ไม่ block store (แค่ warn) |
| Prompt ยาวเกิน จาก memory layers | กลาง | จำกัด total XML ไม่เกิน 2,000 tokens + truncate กลุ่มที่น้อยสำคัญสุดก่อน |
| Performance: 6 parallel queries แทน 4 | ต่ำ | Oracle อยู่บน internal network, latency <10ms ต่อ query |

---

## Success Criteria

| # | Criteria | วิธีวัด |
|---|---------|---------|
| 1 | User Model ถูกสร้างและดึงได้ | `GET /api/user-model?userId=default` → return model |
| 2 | Agent ปรับ response ตาม preference | ตั้ง `responseLength: 'concise'` → AI ตอบสั้นลง |
| 3 | Procedural Memory ถูกสร้างและค้นได้ | `POST /api/procedural` + `GET /api/procedural?q=deploy` |
| 4 | Episodic Memory มี TTL | Document expires_at ถูก set + purgeExpired() ลบได้ |
| 5 | Decay Score คำนวณถูก | Doc อายุ 69 วัน + access 0 → score ~0.5 |
| 6 | `handleLearn()` ยังทำงานเดิมได้ | ไม่ส่ง `layer` → สร้าง Markdown + SQLite + FTS5 + ChromaDB เหมือนเดิม |
| 7 | Contradiction detection ทำงาน | Learn ข้อมูลที่ขัดแย้ง → return warning |
| 8 | Prompt Builder ส่ง user_model XML | Agent เห็น `<user_model>` ใน system prompt |
| 9 | Search รวม decay score | Doc อายุน้อย > Doc อายุมาก (ที่ score เท่ากัน) |
| 10 | ทุก test ผ่าน | `bun test` → 0 fail |
| 11 | Docker build สำเร็จ | `docker compose build oracle` → success |
| 12 | Oracle healthy หลัง deploy | `/api/health` → ok |
